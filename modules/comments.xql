xquery version "3.0";

(:~
 : This module provides functions to handle comments.
 :)
module namespace comments="http://apps.jmmc.fr/exist/apps/oidb/comments";

import module namespace login="http://apps.jmmc.fr/exist/apps/oidb/login" at "login.xqm";
import module namespace templates="http://exist-db.org/xquery/templates";
import module namespace config="http://apps.jmmc.fr/exist/apps/oidb/config" at "config.xqm";
import module namespace helpers="http://apps.jmmc.fr/exist/apps/oidb/templates-helpers" at "templates-helpers.xql";


(: the resource path for comments :)
declare variable $comments:comments := $config:data-root || '/comments/comments.xml';


(:~
 : Add the comments attached to a granule to the model for templating.
 :
 : @param $node  the current node
 : @param $model the current model
 : @param $id    the granule id
 : @return a new model with comments for the granule
 :)
declare function comments:comments($node as node(), $model as map(*), $id as xs:integer) as map(*) {
    map { 'comments' := doc($comments:comments)/comments/comment[@granule-id=$id] }
};

(:~
 : Add the last comments attached to the model for templating.
 : 
 : @param $node
 : @param $model
 : @param $maxComments max number of elements to return (optional)
 : @return the report generated by log module
 :)
declare 
%templates:wrap
%templates:default("maxComments", 10)
function comments:last-comments($node as node(), $model as map(*), $maxComments as xs:integer) as map(*) {
    map { 'comments' := subsequence(reverse(doc($comments:comments)//comment), 1, $maxComments) }
};

(:~
 : Find and add a comment to the current model for templating.
 : 
 : The comment is taken from the current model if available. Otherwise it is
 : searched by id from a request parameter named 'id'.
 : 
 : It adds a bookmark to the current node as an 'id' attribute with the
 : comment id as value.
 : 
 : @param $node  the template for rendering a comment
 : @param $model the current model
 : @return templatized node with comment data
 :)
declare function comments:comment($node as node(), $model as map(*)) as node() {
    let $comment :=
        if (map:contains($model, 'comment')) then
            map:get($model, 'comment')
        else if ('id' = request:get-parameter-names()) then
            let $id := request:get-parameter('id', false())
            return doc($comments:comments)//comment[@id=$id]
        else
            ()
    return
        element { node-name($node) } {
            $node/@* except $node/@id,
            attribute { 'id' } { $comment/@id },
            templates:process($node/node(), map:new(( $model , map:entry('comment', $comment) )))
        }
};

(:~
 : Get the type of a given comment for templating.
 :
 : @param $node  the placeholder for the comment type
 : @param $model the current model
 : @param $key   the key to the comment in model
 : @return "new" if this comment is not in reply to a previous comment, "reply" else.
 :)
declare function comments:get-comment-type($node as node(), $model as map(*), $key as xs:string) as xs:string{
    let $comment := helpers:get($model, $key)
    return if ( exists($comment/parent::comment) ) then "reply" else "new"
};

(:~
 : Get the url of a given comment for templating.
 :
 : @param $node  the parent of the new text node or new attribute with URL
 : @param $model the current model
 : @param $key   the key to the comment in model
 : @param $attribute-name leave empty to return a string else an attribute will be returned with the given name
 : @return the page where the comment is displayed.
 :)
declare %templates:wrap function comments:get-comment-url($node as node(), $model as map(*), $key as xs:string, $attribute-name as xs:string?) {
    let $comment := helpers:get($model, $key)
    let $granule-id := data($comment/@granule-id)
    let $comment-id := data($comment/@id)
    let $url := if ($granule-id) then "show.html?id="||$granule-id||"#"||$comment-id else ()
    let $res := if($url) then
                    if ($attribute-name) then
                        attribute {$attribute-name} {$url}
                    else
                        $url
                else
                    ()
    return ($res, templates:process($node/node(), $model))
};
