xquery version "3.0";

(:~
 : This module provides functions to handle comments.
 :)
module namespace comments="http://apps.jmmc.fr/exist/apps/oidb/comments";

import module namespace login="http://apps.jmmc.fr/exist/apps/oidb/login" at "login.xqm";
import module namespace templates="http://exist-db.org/xquery/templates";


(: the resource path for comments :)
declare variable $comments:comments := $config:data-root || '/comments/comments.xml';


(:~
 : Insert a new comment for a granule.
 :
 : Only comments from authenticated users are accepted. The comment is
 : otherwise discarded.
 :
 : @param $node    the current node
 : @param $model   the current model
 : @param $id      the id of the granule the comment is for
 : @param $parent  the id of the comment this new comment is a reply of
 : @param $message the text message
 :)
declare function comments:add-comment($node as node(), $model as map(*), $id as xs:integer, $parent as xs:string?, $message as xs:string) as node()? {
    (: FIXME do not use email for user id :)
    let $user := login:user-email()
    return if ($user and request:get-method() = 'POST') then
        let $comments := doc('/db/apps/oidb-data/comments/comments.xml')/comments
        let $parent := if ($parent) then $comments//comment[@id=$parent] else $comments
        let $comment :=
            <comment id="{ util:uuid() }" granule-id="{ $id }">
                <author>{ $user }</author>
                <date>{ current-dateTime() }</date>
                <text>{ $message }</text>
            </comment>
        return update insert $comment into $parent
    else
        ()
};

(:~
 : Add the comments attached to a granule to the model for templating.
 :
 : @param $node  the current node
 : @param $model the current model
 : @param $id    the granule id
 : @return a new model with comments for the granule
 :)
declare function comments:comments($node as node(), $model as map(*), $id as xs:integer) as map(*) {
    map { 'comments' := collection('/db/apps/oidb-data/comments')/comments/comment[@granule-id=$id] }
};

(:~
 : Add the last comments attached to the model for templating.
 : 
 : @param $node
 : @param $model
 : @param $maxComments max number of elements to return (optional)
 : @return the report generated by log module
 :)
declare 
%templates:wrap
%templates:default("maxComments", 10)
function comments:last-comments($node as node(), $model as map(*), $maxComments as xs:integer) as map(*) {
    map { 'comments' := subsequence(reverse(collection('/db/apps/oidb-data/comments')//comment), 1, $maxComments) }
};

(:~
 : Get the type of a given comment for templating.
 :
 : @param $node  the placeholder for the comment type
 : @param $model the current model
 : @param $key   the key to the comment in model
 : @return "new" if this comment is not in reply to a previous comment, "reply" else.
 :)
declare function comments:get-comment-type($node as node(), $model as map(*), $key as xs:string) as xs:string{
    let $comment := map:get($model, $key)
    return if ( exists($comment/parent::comment) ) then "reply" else "new"
};

(:~
 : Get the url of a given comment for templating.
 :
 : @param $node  the parent of the new text node or new attribute with URL
 : @param $model the current model
 : @param $key   the key to the comment in model
 : @param $attribute-name leave empty to return a string else an attribute will be returned with the given name
 : @return the page where the comment is displayed.
 :)
declare %templates:wrap function comments:get-comment-url($node as node(), $model as map(*), $key as xs:string, $attribute-name as xs:string?) {
    let $comment := map:get($model, $key)
    let $granule-id := data($comment/@granule-id)
    let $comment-id := data($comment/@id)
    let $url := if ($granule-id) then "show.html?id="||$granule-id||"#"||$comment-id else ()
    let $res := if($url) then
                    if ($attribute-name) then
                        attribute {$attribute-name} {$url}
                    else
                        $url
                else
                    ()
    return ($res, templates:process($node/node(), $model))
};
